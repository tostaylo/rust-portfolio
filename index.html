<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Torre Taylor</title>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="Description" content="Torre Taylor's portfolio site built with Rust Wasm and rust_fel." />
		<link rel="preload" href="./main.css" as="style" />
		<link crossorigin rel="preload" href="./pkg/rust-fel-portfolio_bg.wasm" as="fetch" />
		<!-- <link crossorigin rel="preload" href="./index.js" as="script" /> -->
		<link crossorigin rel="preload" href="./pkg/rust-fel-portfolio.js" as="script" />
		<link rel="stylesheet" href="./main.css" />
		<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png" />
		<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png" />
		<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png" />
		<link rel="manifest" href="/site.webmanifest" />
	</head>
	<body>
		<!-- Note the usage of `type=module` here as this is an ES6 module -->
		<div id="root"></div>
		<!-- <script src="./index.js" type="module"></script> -->
		<script type="module">
			// Use ES module import syntax to import functionality from the module
			// that we have compiled.
			//
			// Note that the `default` import is an initialization function which
			// will "boot" the module and make it ready to use. Currently browsers
			// don't support natively imported WebAssembly as an ES module, but
			// eventually the manual initialization won't be required!
			import init from './pkg/rust-fel-portfolio.js';

			async function run() {
				// First up we need to actually load the wasm file, so we use the
				// default export to inform it where the wasm file is located on the
				// server, and then we wait on the returned promise to wait for the
				// wasm to be loaded.
				//
				// It may look like this: `await init('./pkg/without_a_bundler_bg.wasm');`,
				// but there is also a handy default inside `init` function, which uses
				// `import.meta` to locate the wasm file relatively to js file.
				//
				// Note that instead of a string you can also pass in any of the
				// following things:
				//
				// * `WebAssembly.Module`
				//
				// * `ArrayBuffer`
				//
				// * `Response`
				//
				// * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
				//
				// This gives you complete control over how the module is loaded
				// and compiled.
				//
				// Also note that the promise, when resolved, yields the wasm module's
				// exports which is the same as importing the `*_bg` module in other
				// modes
				await init();

				// And afterwards we can use all the functionality defined in wasm.
				// const result = add(1, 2);
				// console.log(`1 + 2 = ${result}`);
				// if (result !== 3) throw new Error("wasm addition doesn't work!");
			}

			run();
		</script>
	</body>
</html>
