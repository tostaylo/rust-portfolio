<p>Is your website fast? Fast can mean many things in the context of a website. During page load, when does a user see a page element? Does that element move? When the user clicks a button does it function? These things matter not only on page load but also for the duration a user is interacting with your site.</p>
<p>There are many tools out there to help us measure user-centric metrics which occur on page load. <a href="https://developers.google.com/web/tools/lighthouse">Lighthouse</a>, <a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeedInsights</a>, and <a href="https://www.webpagetest.org/">WebPageTest</a> to name a few. We see less tooling which allows us to universally measure all user interactions on our site. This is due to how each site has its own unique requirements and unique user interactions. It is up to us to tailor post page-load, user-centric performance testing suite, based on what our site requirements are.</p>
<h2 id="whattotest">What to Test</h2>
<h3 id="changingroutesinaspa">Changing routes in a SPA</h3>
<p>Navigating from a landing page to the page the user will likely visit next</p>
<h3 id="priorityinteractions">Priority Interactions</h3>
<p>Account registration, view cart, show data visualizations, etcâ€¦</p>
<h2 id="definebaselines">Define Baselines</h2>
<p>After reading the article <a href="https://blog.uptrends.com/web-performance/the-psychology-of-web-performance/">The Psychology of Web Performance</a> and it's excerpt from <a href="https://www.nngroup.com/books/usability-engineering/">Usability Engineering</a> there are " <a href="https://www.nngroup.com/articles/response-times-3-important-limits/">3 important limits</a> to keep in mind when optimizing web and application performance."</p>
<ul>
<li>A user feels a response is instantaneous at a .01 second.</li>
<li>A user experiences uninterrupted flow with 1 second response times.</li>
<li>Once response times exceed 10 seconds, user attention suffers breaking flow and frustration rises.</li>
</ul>
<p>When defining baselines to determine success or failures keep these limits in mind.</p>
<h2 id="whattoolswillweuse">What Tools Will We Use?</h2>
<p><a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> - Headless browser Node.js library.</p>
<ul>
<li>Navigates to web pages</li>
<li>Enables interaction with Chrome Developer Tools Protocol</li>
<li>Interacts with our pages as a user would</li>
</ul>
<p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference">Chrome Developer Tools Performance Timeline</a></p>
<ul>
<li>Enables recording events occuring in the browser on page load or user interactions.</li>
</ul>
<p><img src="/assets/images/chrome-perf-click.webp" alt="Perf Timeline View" /></p>
<h2 id="process">Process</h2>
<p>Assuming you've already installed Node and Puppeteer, let's look at a starting point for your Node.js script taken from <a href="https://addyosmani.com/blog/puppeteer-recipes/">this great blog post</a> by Addy Osmani .</p>
<pre><code class="javascript language-javascript">const puppeteer = require('puppeteer');

(async () =&gt; {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    const navigationPromise = page.waitForNavigation();
    await page.goto('https://pptr.dev/#?product=Puppeteer&amp;version=v2.1.1&amp;show=outline');
    await page.setViewport({ width: 1440, height: 714 });
    await navigationPromise;
    const selector = 'body &gt; sidebar-component &gt; sidebar-item:nth-child(3) &gt; .pptr-sidebar-item';
    await page.waitForSelector(selector);
    await page.tracing.start({ path: 'trace.json', screenshots: true });
    await page.click(selector);
    await page.tracing.stop();

    await browser.close();
})();
</code></pre>
<p>What you see above is the basic idea.</p>
<ol>
<li><p>Start a new browser instance</p></li>
<li><p>Navigate to a url</p></li>
<li><p>Start a trace</p></li>
<li><p>Select an element on the page and click it</p></li>
<li><p>Stop the trace</p></li>
</ol>
<p>The output of the trace file generated will look something like this:</p>
<pre><code class="json language-json">{
    "traceEvents": [
        {
            "args": { "data": { "type": "click" } },
            "cat": "devtools.timeline",
            "dur": 7761,
            "name": "EventDispatch",
            "ph": "X",
            "pid": 61589,
            "tdur": 7706,
            "tid": 775,
            "ts": 161565081204,
            "tts": 119022
        },
        {
            "args": {
                "cat": "devtools.timeline,rail",
                "dur": 18,
                "name": "Paint",
                "ph": "X",
                "pid": 61589,
                "tdur": 18,
                "tid": 775,
                "ts": 161565160795,
                "tts": 196604
            }
        }
    ]
}
</code></pre>
<p><figcaption>Here is the <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit">documentation</a> on the trace file and what the key value pairs represent.</figcaption></p>
<p>The trace file contains a traceEvents array. If we analyze these events we can identify the browser rendering events of "click", "Layout", "UpdateLayoutTree", "Paint", "CompositeLayers". Each event has the values of</p>
<pre>ts = time start; dur = duration</pre>
<pre>ts: The tracing clock timestamp of the event. The timestamps are provided at microsecond granularity.
There is an extra parameter dur to specify the tracing clock duration of complete events in microseconds. All other parameters are the same as in duration events. The ts parameter indicate the time of the start of the complete event. Unlike duration events, the timestamps of complete events can be in any order. An optional parameter tdur specifies the thread clock duration of complete events in microseconds.</pre>
<p>In order to accurately measure how long the user interaction has taken we need to look at the trace file and identify the browser rendering events. <a href="https://developers.google.com/web/fundamentals/performance/rendering">This article</a> by Paul Irish explains it as the "Pixel Pipeline."</p>
<ul>
<li>User Interaction Event (often JavaScript or CSS Animations)</li>
<li>Style</li>
<li>Layout</li>
<li>Paint</li>
<li>Composite</li>
</ul>
<p>If we follow the order of events of the "pixel pipeline" we should be able to determine the total duration of the rendering process initiated from the user interaction by subtracting the "User Interaction" event start time (click in our case) from the sum of the start time and the duration of the final "Composite" event.</p>
<p><img src="/assets/images/chrome-perf-full.webp" alt="Perf Timeline View" /></p>
<p><figcaption>If we upload the trace event file into the Chrome Developer Tools Performance Timeline tool we can view the events graphically.</figcaption></p>
<p>That's all there is to it! Utilizing this tooling and knowledge of the browser's rendering process we can create baselines, execute user interactions, and analyze the resulting timings of interactions.</p>
<p>Coming soon, part 2 of this series will be an example project I've created which follows this process.</p>